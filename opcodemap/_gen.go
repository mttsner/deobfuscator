// +build ignore
package main

import (
	//"./notadeobfuscator/beautifier"
	//"github.com/yuin/gopher-lua/parse"
	"os"
	//"strings"
	"text/template"
	"./notadeobfuscator/deobfuscator/opcodemap"
	"math/rand"
)

func randomString(n int) string {
    var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
 
    s := make([]rune, n)
    for i := range s {
        s[i] = letters[rand.Intn(len(letters))]
    }
    return string(s)
}

func main() {
	/*variables := map[string]byte{
		"Stk":        beautifier.Stack,
		"Inst":       beautifier.Instruction,
		"Env":        beautifier.Environment,
		"Upvalues":   beautifier.Upvalues,
		"InstrPoint": beautifier.Pointer,
		"OP_A":       beautifier.A,
		"OP_B":       beautifier.B,
		"OP_C":       beautifier.C,
		"OP_ENUM":    beautifier.MOVE,
		"OP_MOVE":    beautifier.ENUM,
	}

*/	opcodes := make(map[string]string)

	for _, function := range opcodemap.OpCodes {
		hash := randomString(10)

		opcodes[hash] = function
	}

	f, err := os.Create("opcodes.go")
	defer f.Close()
	if err != nil {

	}
	
	opcodesTemplate.Execute(f, struct {
		Opcodes map[string]string
	}{
		Opcodes: opcodes,
	})
}

var opcodesTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package opcodemap

var Opcodes = map[string]func(*Instruction)uint32 {
{{- range $hash, $function := .Opcodes }}
	{{ printf "%q : %s" $hash $function }},
{{- end }}
}`))